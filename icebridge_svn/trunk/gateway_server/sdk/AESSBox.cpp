/*
 * AESBox.cpp
 *
 *  Created on: Sep 11, 2013
 *      Author: root
 */

#include "AESSBox.h"
#include  "RandomUtil.h"


unsigned char global_aesbox[TOTALBOXES][256];

AESSBox::AESSBox() {
	// TODO Auto-generated constructor stub
    //AESSBox::generateBox(0x0100);
}

AESSBox::~AESSBox() {
	// TODO Auto-generated destructor stub
}

#include <stdio.h>
void AESSBox::getBox(unsigned char * pBox,unsigned char * &pRandoms) {

	RandomUtil::getBoxofRandoms(pRandoms);

	AESSBox::formNewBoxes(pBox,pRandoms);

}

void AESSBox::generateBox(DBYTE mx) {

	static unsigned int boxIndex = 0;
	DBYTE value, valuecount = 0;
	BYTE matrixed_value = 0;
	BYTE marked[256];

	if (boxIndex >= TOTALBOXES) {

		return;
	}

	memset(marked, 0, 256 * sizeof(BYTE));

	while (1) {
		value = valuecount;
		DBYTE myout = 1;
		for (int i = 1; i <= 7; i++) {
			value = mod(mul(value), mx);
			myout = mod(multwo(myout, value), mx);
		}

		matrixed_value = matrix(myout);
		if (marked[valuecount] != '\0') {
			break;
		}

		//this is the original box generated by aes
		global_aesbox[boxIndex][valuecount] = matrixed_value;


		valuecount++;

		if (valuecount == 256) {

			//boxIndex++;
			//ues global_aesbox[1] as temp box
			//memcpy(global_aesbox[boxIndex+1],global_aesbox[boxIndex],sizeof(global_aesbox[boxIndex]));
			//formNewBoxes(boxIndex);
			break;
		}
	}
}

void AESSBox::formNewBoxes(unsigned char *pBox,unsigned char * &pRandoms) {

	BYTE randomIndex1 = 0;
	BYTE randomIndex2 = 0;
	BYTE tempRandom = 0;

	//for (int i = 0; i < 1; i++)
	{

		//copy the original box to the new box which will be exchanged
		memcpy(pBox, global_aesbox[0],sizeof(global_aesbox[0]));

		for (int j = 0; j < EXCHANGETIMES*2; j += 2) {

			randomIndex1 = pRandoms[j];
			randomIndex2 = pRandoms[j+1];

			//exchange the num in the new box
			tempRandom = pBox[randomIndex1];
			pBox[randomIndex1] = pBox[randomIndex2];
			pBox[randomIndex2] = tempRandom;
		}
	}
}
